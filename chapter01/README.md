# 타입스크립트 알아보기

타입 시스템을 알기 전에 몇 가지 체크할 사항

### 1. 타입스크립트와 자바스크립트의 관계

- 타입스크립트는 문법적으로 자바스크립트의 상위 집합(superset)이다.

  - 자바스크립트 파일의 코드는 타입스크립트의 코드라고 할 수 있다.
  - 그래서, 자바스크립트 > 타입스크립트로 마이그레이션하는 데 이점이 있다.
  - 반대로 타입스크립트는 타입을 명시하는 문법이 있기 때문에 자바스크립트가 아닐 수 있다.
  
    > 스트링 타입을 명시한 (e.g. `function a(str :string) {}`) 구문은 자바스크립트를 구동하는
    > node 프로그램에서 실행하면 오류가 발생한다.
    
  - 확장자명은 `.ts` 혹은 `.tsx`를 사용
  
#### * 타입스크립트는 타입 추론을 사용

- 타입 시스템은 런타임에 오류를 발생시킬 코드를 미리 찾는다. (이는 '정적' 타입 시스템의 특징이다.)

- 객체 내의 프로퍼티 값을 잘못 접근하는 경우 코드는 정상적으로 흘러가지만 출력 값은 `undefined`와 같이 예상치 못한 결과를 보여준다.

    - 이 때, 명시적인 타입 체커를 사용한다면 오타와 같은 잠재적 오류를 쉽게 발견할 수 있다.

#### * 타입 시스템이 정적 타입의 정확성을 보장해주지 않는다.

<br/>

### 2. 타입스크립트 설정 이해

- 타입스크립트에는 수 많은 설정 옵션들이 있다.
- 커맨드라인 및 **`tsconfig.json`** 설정 파일에서도 사용 가능하다.
- 설정 파일은 `tsc --init`을 실행하면 간단히 생성된다.
- `noImplicitAny` : 변수들이 미리 정의된 타입을 가져야 하는지 여부 체크

    - 해당 설정이 적용되지 않는다면, 매개변수는 암시적으로 `any` 타입으로 간주된다.
    - 타입 문제를 발견하기 수월해지고, 코드 가독성이 좋아지고, 개발자의 생산성이 향상된다.
    - 자바스크립트를 타입스크립트로 전환하는게 아니라면 이 옵션을 사용하는게 좋다.
    
- `strictNullChecks` : `null` 과 `undefined`가 모든 타입에서 허용되는지 체크

    - 이 옵션을 사용하려면 `noImplicitAny`를 먼저 설정해야 한다.
    - `null`과 `undefined` 관련 오류를 잡아 내는 데 많은 도움이 되지만, 코드 작성을 어렵게 한다.
    - 개발 초반에 설정하는 것이 좋다..!
    
- 엄격한 체크를 하고 싶다면 `strict` 설정을 고려한다.

<br/>

### 3. 코드 생성과 타입이 관계 없음을 이해

- 타입스크림트 컴파일러의 두 가지 역할

  - 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 한다.
  - 코드의 타입 오류를 체크한다.
  
#### 이 두 가지 역할은 독립적으로 실행되기 때문에, 코드에 오류가 있더라도 컴파일을 수행한다. (코드가 생성된다.)

- 코드에 오류가 있을 때 타입 체크에 문제가 있다고 보면 된다.
- 문제가 된 오류를 수정하지 않더라도 애플리케이션의 다른 부분을 테스트 할 수 있다.
- 만약 오류가 있을 떄 컴파일을 중단하려면 `noEmitOnError` 옵션을 설정하면 된다.

#### 런타임에는 타입 체크가 불가능 하다.
- 명시적으로 지정된 인터페이스와 같은 타입 구문은 런타임 시 제거된다.
- 타입 체크를 명확하게 하려면 런타임에 타입 정보를 유지하는 방법을 사용한다.

    1. 객체의 속성이 존재하는지 체크한다.
    2. 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 '태그' 기법을 사용한다.
    3. 타입을 클래스로 만든다. (타입 선언에서는 클래스가 타입으로 참조되고, `instance of` 타입 체크에서는 값으로 참조된다.)
    
#### 타입 연산은 런타임에 영향을 주지 않는다.

- `as {타입}` 구문은 타입 연산(?), 타입 단언문 이라고 한다.
- 타입 연산은 런타임 동작에는 아무런 영향을 미치지 않는다. 

#### 런타임 타입은 선언된 타입과 다를 수 있다.

- 함수 매개변수에 명시적으로 타입을 선언했지만 런타임에서는 다른 타입으로 들어올 수 있다.
- 예를 들어, api 호출이 런타임 시에 일어날 수 있는데 이 때 호출된 api의 응답 값의 타입이 바뀌어도
기존에 명시적으로 타입을 선언했음에도 불구하고 다른 타입 값이 들어올 수 있다.

#### 타입스크립트 타임으로는 함수를 오버로드 할 수 없다.

- 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체는 오직 하나뿐이다.
- 온전히 타입 수준에서만 동작한다.

#### 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

- 자바스크립트로 빌드할 때 타입과 타입 연산자는 모두 제거되기 때문에, 런타임의 성능에 영향을 주지 않는다.
- 대신, 타입스크립트 컴파일러는 '빌드타임' 오버헤드가 있다.
- 이는 호환성과 성능 사이의 선택인데 컴파일 타깃과 언어 레벨의 문제이다. 타입과는 무관하다.  

<br/>

### 4. 구조적 타이핑에 익숙해지기

- 자바스크립트는 덕 타이핑 기반이다. 타입스크립트는 이를 모델링하기 위해 구조적 타이핑을 사용한다.
- 어떤 함수에서 매개변수로 들어오는 값이 어떤 값이든 매개변수와 호환이 되면, 런타임 동작에 아무런 문제가 없다.
- 이를 타입이 '열려 있다.'라고 표현 하는데 이는 객체가 타입에 선언 되어 있는 속성과 다른 속성을 가질 수 있고,
이로 인해 결과 값이 달라져 문제를 발생시킬 수 있다.
- 구조적 타이핑의 이슈를 피하기 위해서 모든 속성을 루프하기보다 각각 처리하는 것이 좋다.
- 테스트를 작성할 때, 그리고 라이브러리 간의 의존성을 분리하기 위해서는 구조적 타이핑이 유리하다. 

<br/>

### 5. any 타입 지양하기
- 타입 안정성이 없다.
- 함수 시그니처(contract)(=? 약속)을 무시한다.
- 개발 툴에서 자동완성 기능과 도움말 제공 기능이 적용되지 않는다.
- 코드 리팩토링 때 버그를 감춘다.
- 더 많지만 아무튼 지양하자!
